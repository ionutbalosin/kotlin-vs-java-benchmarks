# JMH version: 1.21
# VM version: JDK 11.0.2, Java HotSpot(TM) 64-Bit Server VM, 11.0.2+9-LTS
# VM invoker: /usr/lib/jvm/jdk-11.0.2/bin/java
# VM options: <none>
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: org.ib.benchmark.HighOrderFunctionJavaBenchmark.sumOfSquares
# Parameters: (param = 1000000)

# Run progress: 0.00% complete, ETA 00:01:00
# Fork: 1 of 3
# Warmup Iteration   1: 3.852 ms/op
# Warmup Iteration   2: 3.100 ms/op
# Warmup Iteration   3: 3.119 ms/op
# Warmup Iteration   4: 3.071 ms/op
# Warmup Iteration   5: 3.051 ms/op
Iteration   1: 3.102 ms/op
Iteration   2: 3.032 ms/op
Iteration   3: 3.090 ms/op
Iteration   4: 3.064 ms/op
Iteration   5: 3.086 ms/op

# Run progress: 16.67% complete, ETA 00:00:51
# Fork: 2 of 3
# Warmup Iteration   1: 3.645 ms/op
# Warmup Iteration   2: 3.315 ms/op
# Warmup Iteration   3: 3.104 ms/op
# Warmup Iteration   4: 3.126 ms/op
# Warmup Iteration   5: 3.092 ms/op
Iteration   1: 3.070 ms/op
Iteration   2: 3.156 ms/op
Iteration   3: 3.023 ms/op
Iteration   4: 3.118 ms/op
Iteration   5: 3.018 ms/op

# Run progress: 33.33% complete, ETA 00:00:41
# Fork: 3 of 3
# Warmup Iteration   1: 3.563 ms/op
# Warmup Iteration   2: 3.392 ms/op
# Warmup Iteration   3: 2.999 ms/op
# Warmup Iteration   4: 3.145 ms/op
# Warmup Iteration   5: 2.999 ms/op
Iteration   1: 2.989 ms/op
Iteration   2: 3.133 ms/op
Iteration   3: 3.092 ms/op
Iteration   4: 3.132 ms/op
Iteration   5: 3.218 ms/op


Result "org.ib.benchmark.HighOrderFunctionJavaBenchmark.sumOfSquares":
  3.088 ±(99.9%) 0.064 ms/op [Average]
  (min, avg, max) = (2.989, 3.088, 3.218), stdev = 0.060
  CI (99.9%): [3.025, 3.152] (assumes normal distribution)


# JMH version: 1.21
# VM version: JDK 11.0.2, Java HotSpot(TM) 64-Bit Server VM, 11.0.2+9-LTS
# VM invoker: /usr/lib/jvm/jdk-11.0.2/bin/java
# VM options: <none>
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: org.ib.benchmark.HighOrderFunctionKtBenchmark.sumOfSquares
# Parameters: (param = 1000000)

# Run progress: 50.00% complete, ETA 00:00:31
# Fork: 1 of 3
# Warmup Iteration   1: 0.419 ms/op
# Warmup Iteration   2: 0.407 ms/op
# Warmup Iteration   3: 0.404 ms/op
# Warmup Iteration   4: 0.407 ms/op
# Warmup Iteration   5: 0.405 ms/op
Iteration   1: 0.406 ms/op
Iteration   2: 0.410 ms/op
Iteration   3: 0.405 ms/op
Iteration   4: 0.403 ms/op
Iteration   5: 0.405 ms/op

# Run progress: 66.67% complete, ETA 00:00:20
# Fork: 2 of 3
# Warmup Iteration   1: 0.418 ms/op
# Warmup Iteration   2: 0.416 ms/op
# Warmup Iteration   3: 0.411 ms/op
# Warmup Iteration   4: 0.408 ms/op
# Warmup Iteration   5: 0.414 ms/op
Iteration   1: 0.415 ms/op
Iteration   2: 0.412 ms/op
Iteration   3: 0.415 ms/op
Iteration   4: 0.415 ms/op
Iteration   5: 0.414 ms/op

# Run progress: 83.33% complete, ETA 00:00:10
# Fork: 3 of 3
# Warmup Iteration   1: 0.428 ms/op
# Warmup Iteration   2: 0.405 ms/op
# Warmup Iteration   3: 0.410 ms/op
# Warmup Iteration   4: 0.405 ms/op
# Warmup Iteration   5: 0.407 ms/op
Iteration   1: 0.406 ms/op
Iteration   2: 0.407 ms/op
Iteration   3: 0.408 ms/op
Iteration   4: 0.407 ms/op
Iteration   5: 0.406 ms/op


Result "org.ib.benchmark.HighOrderFunctionKtBenchmark.sumOfSquares":
  0.409 ±(99.9%) 0.005 ms/op [Average]
  (min, avg, max) = (0.403, 0.409, 0.415), stdev = 0.004
  CI (99.9%): [0.404, 0.413] (assumes normal distribution)


# Run complete. Total time: 00:01:02

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                                    (param)  Mode  Cnt  Score   Error  Units
HighOrderFunctionJavaBenchmark.sumOfSquares  1000000  avgt   15  3.088 ± 0.064  ms/op
HighOrderFunctionKtBenchmark.sumOfSquares    1000000  avgt   15  0.409 ± 0.005  ms/op

Few thoughts:
    - Inlining the function at call-sites saves the lambda objects to be created which in essence it means less memory allocations and less virtual calls
    - The bytecode from Kotlin code looks like below:

        @Benchmark
        public final long sumOfSquares() {              <<-- Inlined version
            int max$iv = this.param;
            int $i$f$sumOfSquares = false;
            long sum$iv = 0L;
            int i$iv = 1;
            int var7 = max$iv;
            if (i$iv <= max$iv) {
            while(true) {
                int var9 = false;
                int var12 = i$iv * i$iv;
                sum$iv += (long)var12;
                if (i$iv == var7) {
                    break;
                }

                ++i$iv;
                }
            }

            return sum$iv;
        }
    - in Java it pays the cost of INVOKEDYNAMIC and INVOKEVIRTUAL calls (as a result of lambda objects created)